---
title: "Single Cell RNA Sequence Analysis Pipeline Guide"
author: "Craig McDougall"
date: "October 2020"
#set figure widths
#output: html_document
#output: 
# html_document:
#    toc: true
output: pdf_document
#output: ioslides_presentation
  
---

```{r setup,  include=FALSE}
#echo r code in markdown output,
knitr::opts_chunk$set(echo = TRUE)
 
```

## Introduction

This document details the stages of a bioinformatic pipeline, designed in R to analyse single cell RNA sequence data. The pipeline was constructed as part of an MSc project at the University of Edinburgh in Scotland. 

The aim of the project was to investigate sexual dimorphism in the central stress response system; the Hypothalmic-pituitary-adrenal (HPA) axis. The pipeline was designed as a tool, to probe the transcriptome profiles of anterior pituitary cells. In the project it facilitated a study of sexual dimorphism in the gene expression of pituitary corticotroph cells, but could also be used on other cell types. 

A similar method has been reported in a recent study of sexual dimorphism in pituitary cells. However, this study concentrated on gonadotroph and lactotroph pituitary cells ^[[Fletcher et.al 2019](https://www.frontiersin.org/articles/10.3389/fendo.2019.00623/full)]^. An underlying limitation of this kind of analysis is that it relies on inferring protein levels by measuring transcription levels, it is not a direct measurement of the proteins present.

The pipeline files can be found on [GitHub](https://github.com/cmcdougall5/scRNAseq_pipeline).

The [Seurat R. package](https://satijalab.org/seurat/) forms the foundation of this pipeline and is in particular based on the [guided clustering tutorial](https://satijalab.org/seurat/v3.2/pbmc3k_tutorial.html), but updated to include the `SCTransform` normalisation function.  

Example single cell RNA sequence data is available in public repositories. In the project the pipeline was designed for, the following data sets were examined:

*   [Chung et al](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE120410). 
*   [Mayran et al](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi). 
*   [Ho et al](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi). 
*   [Fletcher et al](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE132224). 

Details on the data acquisition of these datasets is described within the following publications:

*  [Chung et al](https://academic.oup.com/endo/article/159/12/3910/5133692). 
*  [Mayran et al](https://www.nature.com/articles/s41467-019-11791-9). 
*  [Ho et al](https://link.springer.com/article/10.1007/s13238-020-00705-x). 
*  [Fletcher et al](https://www.frontiersin.org/articles/10.3389/fendo.2019.00623/full). 

The pipeline is comprised of the following steps;

## Step 1. Call Libraries & Set Directories

Before the main body of the pipeline is run, all of the required libraries are called;

```{r Initialising required libraries, message=FALSE}

library(dplyr) 
library(Seurat)
library(patchwork)
library(sctransform)
library(ggplot2)
library(scales)
```

The working directories are then set:
``` {r Set Directories}
#set the working directory to directory wish to read data from and save analysis results to
data.dir <- setwd(here::here())
#check working directory
getwd()

#list all the files in the data directory, to make sur this is where we expect to be
list.files(data.dir)
#have now seen that the files are there and ok to proceed

```
The raw count and gene data is read in from the 10X sequence data files downloaded from the public repositories. Seurat expects `barcodes.tsv`, `matrix.tsv` and `matrix.mtx` files. These are then used to initialise a Seurat object for the transcriptome analysis. 

Please note the folder name will be relative to your own path.

```{r Loading in the Data & Initialising Seurat, echo=FALSE}
#load raw data using Read10x, this will be relative to your path, name desired folder e.g.  "Cheung Data"
raw.data <- Read10X("Cheung Data")

#initialise a Seurat object with the raw (not normalised) data. This is a count matrix
data <- CreateSeuratObject(counts=raw.data, project = "data", min.cells = 3, min.features = 200) 
```

## Step 3. Quality control plots

Before processing the data, some quality control plots are made to assess the quality of the data and explore confounding factors such as assessing the number of reads that map to mitochondrial genome.
```{r Data visualisation/Quality control, echo=FALSE,fig.height=3.5}
#Seurat recommends percent.MT label for mitochondria data, however;
#Cheung, Ho & Mayran et.al. use "percent.mt"
data <- PercentageFeatureSet(data, pattern = "^mt-", col.name = "percent.mt")
#Fletcher uses "percent.Mt"
#data <- PercentageFeatureSet(data, pattern = "^mt-", col.name = "percent.MT")
#select appropriate method and comment out other option

#use QC metrics to filter the cells
#visualise the QC metrics - use a violin plot 
VlnPlot(data, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)

#make the plots
plot1 <- FeatureScatter(data, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(data, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
#then plot
plot1 + plot2
```

The QC plots to inform which cells should be excluded on quality basis (low quality, double counts). This is achieved using the `subset` function. For example to exclude cells with less than 200 counts and more than 2500 and greater than 5% mitochondrial DNA confounding factor;

```{r Subset the data }
data <- subset(data, subset = nFeature_RNA > 200 & nFeature_RNA <2500 & percent.mt < 5)

```
## Step 4.  Transform the data

With the data visualised and trimmed, it must be;


* Normalised to ensure all genes carry equal weight going forward and prevent heavily expressing genes from being over represented.
* Regressed to remove confounding factors such as areas mapped to the mitochondrial genome.
* Assessed for variable genes. 

The [SCTransform](https://satijalab.org/seurat/v3.1/sctransform_vignette.html) function performs all of these actions and greatly simplifies the code, negating the use of four separate functions. 

``` {r Perform Filtering, Normalisation, Regression and variable gene assessment, include=FALSE }
data <- SCTransform(data,vars.to.regress = "percent.mt")#, verbose = FALSE )
```

## Step 5. Dimensional reduction

The first step in dimensional reduction is to conduct principal component analysis (PCA) on the scaled data, using the variable features as the input. PCA transforms the from the table into new features known as principal components, which capture the information of the dataset in a new way.

```{r Perform PCA, echo=FALSE}
data <- RunPCA(data,verbose= FALSE) 

```

An elbow plot can be used to assess which principal components contain the majority of the information and identify which may be removed from the dataset;

``` {r Plot Elbow, echo = FALSE,fig.height=3.5}
#Do we need to keep all PCs, or is majority of data captured by a certain point?
ElbowPlot(data, ndims=30)

```


Uniform Manifold Approximation and Projection (UMAP) is an algorithm for dimensional reduction and is applied on the principal components established in the first step.

``` {r Perform dimensional reduction (UMAP), include=FALSE }

#UMAP dimensional reduction of the identified PCs
data <- RunUMAP(data, dims=1:30, umap.method = "umap-learn", metric = "correlation", verbose=FALSE)

```



## Step 6. Clustering

The first stage in clustering the cells is to establish a shared nearest neighbour (SNN) information for the data by calculating the overlap between each cell based on its k.parameters using a [Seurat function](https://www.rdocumentation.org/packages/Seurat/versions/3.1.4/topics/FindNeighbors).

The clusters cn then be identified based on the SNN using a [clustering algorithm](https://www.rdocumentation.org/packages/Seurat/versions/3.1.4/topics/FindClusters). 

```{r Perform clustering, echo=FALSE}
#Find nearest neighbours
data <- FindNeighbors(data, dims=1:30, verbose=FALSE)

#CLuster based on neighbour distances
data <- FindClusters(data, verbose=FALSE)

```
Once the clusters have been established, they can be projected into two lower dimensional space using a [dimensional reduction plot](https://www.rdocumentation.org/packages/Seurat/versions/3.1.4/topics/DimPlot) for visualisation.

```{r Plot clusters, echo = FALSE,fig.height=3.5}

#plot the clusters
DimPlot(data, label=TRUE) + NoLegend()

```


## Step 7. Cell Type assessment
The main question now, is how well do the clusters approximate cell type? It is difficult to make absolute claims when attributing cell types to empirical cluster data based purely on an *in silico* analysis. However we may approximate the cell type of each cluster based on known canonical expression markers ^[[Fletcher et.al 2019](https://www.frontiersin.org/articles/10.3389/fendo.2019.00623/full)]^ ^[[Chung et.al 2018](https://academic.oup.com/endo/article/159/12/3910/5133692)]^. 


In the corticotroph study, hormone secreting pituitary cell types were identified based on the following canonical gene expression markers: 

 * Thyrotrophs (Pou1f1 + Tshb),
 * Somatotrophs(Pou1f1 + Gh)
 * Lactotrophs (Pou1f1 + Prl)
 * Gonadotrophs (Lhb)
 * Melanotrophs (Pomc + Pcsk2 + Pax7)
 * Corticotrophs (Pomc + Crhr1 + Avpr1b + Gpc5 - Pcsk2 - Pax7)
 
 [Feature plots](https://www.rdocumentation.org/packages/Seurat/versions/3.1.4/topics/FeaturePlot) were used to visually assess gene expression levels of single cells. 

``` {r Perform cell type assessment, message=FALSE,fig.height=3.5}
#Visualise the canonical marker genes 

#first exclude Pou1f1 expressing cells (Thyrotrophs, Somatotrophs, Lactotrophs)
FeaturePlot(data, features = c("Pou1f1","Tshb", "Gh","Prl"), pt.size = 0.2)&scale_color_viridis_c()

#then exclude the gonadotrophs
FeaturePlot(data, features = c("Lhb"), pt.size = 0.2)&scale_color_viridis_c()

#then exclude the melanotrophs
FeaturePlot(data, features = c("Pomc","Pax7","Pcsk2"), pt.size = 0.2)&scale_color_viridis_c() 

#then id the corticotrophs
FeaturePlot(data, features = c("Pomc", "Crhr1","Avpr1b","Gpc5"), pt.size = 0.2)&scale_color_viridis_c() 
```
The first plot would be used to exclude clusters of thyrotrophs, Somatotrophs and lactotrophs. The second plot allows exclusion on gonadotrophs, the third melanotrophs. The final plot allows confirmation of the corticotoph cluster.


## Step 8. Isolate desired cell cluster

To examine cell homogeneity within the corticotrophs, the cluster identified in the previous step was pulled out as a subset. 

The desired cluster must be manually entered upon visual inspection of the gene expression feature plots in the previous step.
``` {r isolate desired cells, echo=FALSE}
#enter the cotricoph cell ids, found in visualisation. Note change to correct cluster #s or will miss-match
#new.cluster.ids <- c("0", "1", "2", "3", "4", "5", "6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22")
new.cluster.ids <- c("0", "1", "2", "3", "4", "5", "6","7","8","9","cort","11","12","13","14","15","16","17","18","19","20")

names(new.cluster.ids) <- levels(data)
```
As a sanity check that the correct cluster was selected, a dimensional reduction plot;

``` {r re-plot clusters with names,fig.height=3.5}
#Rename the cluster
data <- RenameIdents(data, new.cluster.ids)
#then put on the plot to confirm slected the correct one (sanity check)
DimPlot(data, reduction ="umap", label = TRUE, pt.size = 0.5)+NoLegend()
```

And the data for the cluster of interest can be extracted for further study;
``` {r pull out cluster}
cortico <- subset(data, idents = "cort")
```

## Step 9. Re-cluster selected cell cluster

To investigate cell homogeneity within the cell cluster of interest, the same procedure may be repeated;

*Data transformation, identification of principal components (PCA)
*Dimensional reduction (UMAP)
*Identification of nearest neighbours (SNN)
*Clustering using SNN.

``` {r re-cluster selected cluster, include=FALSE}

#dimensional analysis
#PCA to identify PCs
cortico <- RunPCA(cortico,verbose= FALSE) 

#dimensional reduction
#UMAP dimensional reduction of the identified PCs
cortico <- RunUMAP(cortico, dims=1:30, verbose=FALSE) #note because SCTransform passes 3000 features can run more PCs

#Find nearest neighbours
cortico <- FindNeighbors(cortico, dims=1:30, verbose=FALSE)

#CLuster based on neighbour distances
cortico <- FindClusters(cortico, verbose=FALSE)

```

A dimensional reduction plot can then reveal any heterogeneity in the cluster;

```{r cluster homogeneity? plot any clusters of the selected cluster,fig.height=3.5}
#plot the clusters
DimPlot(cortico, pt.size = 5, label=TRUE) + NoLegend()
```

A featureplot can be used to examine gene expression levels across these clusters within the corticotroph data;

``` {r clustre Pomc expression- could be any gene! ,fig.height=3.5}
#Visualise the canonical marker genes 
FeaturePlot(cortico, features = c("Pomc"), pt.size = 5, label=TRUE)& scale_color_viridis_c()
```


Differential expression analysis can reveal differences between the clusters, for example the two top deferentially expressed genes for each cluster are;
```{r examin cluster differential expression, echo=FALSE} 
#examine DE genes in the  corticotroph cluster
#find the markers for EVERY CLUSTER when compared to remaining cells, only +ve ones
cortico.markers <-FindAllMarkers(cortico, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
#examine top 2 deferentially expressed genes in each corticotroph cluster
cortico.markers %>% group_by(cluster) %>% top_n(n=2, wt= avg_logFC)
```

## Summary

The described pipeline is a powerful tool to investigate gene expression and cell homogeneity within sub-populations, however it is just a tool. For meaningful results to be obtained the user must apply knowledge of the samples under study to ensure biologically sensible data is being studied and any decisions based on sound biological features. The output is only as good as the input and parameters.

## Future improvements
A future version of this script will include cell cycle considerations. 

All suggestions for future improvements are welcome, as are comments on the current version. Please make these via the [GitHub](https://github.com/cmcdougall5/scRNAseq_pipeline) page.





    