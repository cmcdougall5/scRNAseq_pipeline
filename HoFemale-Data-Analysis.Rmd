---
title: "Pituitary corticotroph gene expression analysis"
subtitle: "Ho et al 8week female scRNA seq dataset"
author: "Craig McDougall"
date: "October 2020"
#set figure widths
#output: html_document
#output: 
# html_document:
#    toc: true
output: pdf_document
#output: ioslides_presentation
  
---

```{r setup,  include=FALSE}
#echo r code in markdown output,
knitr::opts_chunk$set(echo = TRUE)
 
```



## Introduction

This document details the analysis of the single RNA sequence data by [Ho et al](https://link.springer.com/article/10.1007/s13238-020-00705-x). available from [NCBI](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi).

## Step 1. Call Libraries & Set Directories

Before the main body of the pipeline is run, all of the required libraries are called and 

```{r Initialising required libraries, include =FALSE}

library(dplyr) 
library(Seurat)
library(patchwork)
library(sctransform)
library(ggplot2)
library(scales)
```

the working directories are then set.
``` {r Set Directories, include = FALSE}
#set the working directory to directory wish to read data from and save analysis results to
data.dir <- setwd(here::here())
#check working directory
getwd()

#list all the files in the data directory, to make sur this is where we expect to be
list.files(data.dir)
#have now seen that the files are there and ok to proceed

```
The raw count and gene data is read in from the 10X sequence data files described in [Ho et al](https://link.springer.com/article/10.1007/s13238-020-00705-x) and downloaded from [Ho et al](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi).

For the Ho analysis, the Ho folder is indicted in the path, with the correct sex chosen.

```{r Loading in the Data & Initialising Seurat, include=FALSE}
#load raw data using Read10x, this will be relative to your path, name desired folder e.g.  "Cheung Data"
raw.data <- Read10X("Ho Data/Ho female")

#initialise a Seurat object with the raw (not normalised) data. This is a count matrix
data <- CreateSeuratObject(counts=raw.data, project = "data", min.cells = 3, min.features = 200) 
```
\newpage
## Step 2. Quality control plots

Before processing the data, some quality control plots are made to assess the quality of the data and explore confounding factors such as assessing the number of reads that map to mitochondrial genome.
```{r Data visualisation/Quality control, echo=FALSE,fig.height=3.5}
#Seurat recommends percent.MT label for mitochondria data, however;
#Cheung, Ho & Mayran et.al. use "percent.mt"
data <- PercentageFeatureSet(data, pattern = "^mt-", col.name = "percent.mt")
#Fletcher uses "percent.Mt"
#data <- PercentageFeatureSet(data, pattern = "^mt-", col.name = "percent.MT")
#select appropriate method and comment out other option

#use QC metrics to filter the cells
#visualise the QC metrics - use a violin plot 
VlnPlot(data, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3, pt.size=0)

#make the plots
plot1 <- FeatureScatter(data, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(data, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
#then plot
plot1 + plot2
```

The QC plots to inform which cells should be excluded on quality basis (low quality, double counts). There appear to be separate features in the feature data, so all cells below 200 counts  and above 2000 are dropped and cells with >5% mitochondrial DNA are also dropped. 

```{r Subset the data, include=FALSE } 
#Also drop features > # 
data <- subset(data, subset = nFeature_RNA > 200& nFeature_RNA < 1900  & percent.mt < 5)

```
\newpage
## Step 3.  Transform the data

With the data trimmed to exclued lower quality cells, it must be;

* Normalised to ensure all genes carry equal weight going forward and prevent heavily expressing genes from being over represented.
* Regressed to remove confounding factors such as areas mapped to the mitochondrial genome.
* Assessed for variable genes. 

The [SCTransform](https://satijalab.org/seurat/v3.1/sctransform_vignette.html) function performs all of these actions and greatly simplifies the code, negating the use of four separate functions. 

``` {r Perform Filtering, Normalisation, Regression and variable gene assessment, include=FALSE }
data <- SCTransform(data,vars.to.regress = "percent.mt")#, verbose = FALSE )
```

\newpage
## Step 4. Dimensional reduction

The first step in dimensional reduction is to conduct principal component analysis (PCA) on the scaled data, using the variable features as the input. PCA transforms the from the table into new features known as principal components, which capture the information of the dataset in a new way.

```{r Perform PCA, echo=FALSE}
data <- RunPCA(data,verbose= FALSE) 

```

An elbow plot can be used to assess which principal components contain the majority of the information and identify which may be removed from the dataset;

``` {r Plot Elbow, echo = FALSE,fig.height=3.5}
#Do we need to keep all PCs, or is majority of data captured by a certain point?
ElbowPlot(data, ndims=30)

```

The elbow plot shows that the majority of the information is captured within the first 14 Principal components, so the last 16 are dropped during the next stage.

Uniform Manifold Approximation and Projection (UMAP) is an algorithm for dimensional reduction and is applied on the first 14 principal components established in the first step.

``` {r Perform dimensional reduction (UMAP), include=FALSE }

#UMAP dimensional reduction of the identified PCs, change dims!
data <- RunUMAP(data, dims=1:14, umap.method = "umap-learn", metric = "correlation", verbose=FALSE)

```


\newpage
## Step 5. Clustering

The first stage in clustering the cells is to establish a shared nearest neighbour (SNN) information for the data by calculating the overlap between each cell based on its k.parameters using a [Seurat function](https://www.rdocumentation.org/packages/Seurat/versions/3.1.4/topics/FindNeighbors).

The clusters cn then be identified based on the SNN using a [clustering algorithm](https://www.rdocumentation.org/packages/Seurat/versions/3.1.4/topics/FindClusters). 

```{r Perform clustering, echo=FALSE}
#Find nearest neighbours #change pcs!
data <- FindNeighbors(data, dims=1:14, verbose=FALSE)

#CLuster based on neighbour distances
data <- FindClusters(data, verbose=FALSE)

```
Once the clusters have been established, they can be projected into two lower dimensional space using a [dimensional reduction plot](https://www.rdocumentation.org/packages/Seurat/versions/3.1.4/topics/DimPlot) for visualisation.

```{r Plot clusters, echo = FALSE,fig.height=3.5}

#plot the clusters
DimPlot(data, label=TRUE) + NoLegend()

```

\newpage
## Step 6. Cell Type assessment
The main question now, is how well do the clusters approximate cell type? It is difficult to make absolute claims when attributing cell types to empirical cluster data based purely on an *in silico* analysis. However we may approximate the cell type of each cluster based on known canonical expression markers ^[[Fletcher et.al 2019](https://www.frontiersin.org/articles/10.3389/fendo.2019.00623/full)]^ ^[[Chung et.al 2018](https://academic.oup.com/endo/article/159/12/3910/5133692)]^. 


In the corticotroph study, hormone secreting pituitary cell types were identified based on the following canonical gene expression markers: 

 * Thyrotrophs (Pou1f1 + Tshb),
 * Somatotrophs(Pou1f1 + Gh)
 * Lactotrophs (Pou1f1 + Prl)
 * Gonadotrophs (Lhb)
 * Melanotrophs (Pomc + Pcsk2 + Pax7)
 * Corticotrophs (Pomc + Crhr1 + Avpr1b + Gpc5 - Pcsk2 - Pax7)
 
 [Feature plots](https://www.rdocumentation.org/packages/Seurat/versions/3.1.4/topics/FeaturePlot) were used to visually assess gene expression levels of single cells. Cell type was assigned based on visual inspection of canonical markers ^[Fletcher et al](https://www.frontiersin.org/articles/10.3389/fendo.2019.00623/full),^ ^[Chung et al](https://academic.oup.com/endo/article/159/12/3910/5133692)^.
 
 First the thyrotophs (Pou1f1 + Tshb), somatotrophs (Pou1f1 + Gh) and lactotrops (Pou1f1 + Prl) may be excluded based on gene expression:

``` {r exclude thyro, somato & lacto, echo=FALSE,fig.height=3.5, message=FALSE}
#Visualise the canonical marker genes 

#first exclude Pou1f1 expressing cells (Thyrotrophs, Somatotrophs, Lactotrophs)
FeaturePlot(data, features = c("Pou1f1","Tshb", "Gh","Prl"), pt.size = 0.2)&scale_color_viridis_c()

```
\newpage
Then the Gonadotoprhs may be excluded by Lhb expression;

``` {r exclude gonado, echo=FALSE,fig.height=3.5, message=FALSE}
#Visualise the canonical marker genes 


#then exclude the gonadotrophs
FeaturePlot(data, features = c("Lhb"), pt.size = 0.2)&scale_color_viridis_c()

```


Then the melanotrophs may be excluded based on Pomc, Pcsk2 and Pax7 expression:

``` {r exclude melano, echo=FALSE,fig.height=3.5, message=FALSE}
#Visualise the canonical marker genes 
#then exclude the melanotrophs
FeaturePlot(data, features = c("Pomc","Pax7","Pcsk2"), pt.size = 0.2)&scale_color_viridis_c() 

```

\newpage
Then confirm the identification of the corticotrophs by Pomc, Crh1, Avpr1b and Gpc5.

``` {r confirm corticotrophs, echo=FALSE, fig.height=3.5, message=FALSE}

#Visualise the canonical marker genes 
#then id the corticotrophs

FeaturePlot(data, features = c("Pomc", "Crhr1","Avpr1b","Gpc5"), pt.size = 0.2) &scale_color_viridis_c() 

```

Still dififcult to isolte the corticotroph cluster, seek more canonical genes (from Cheung wt al paper). Note that cluster 3 appears to hold high levels of all genes, could this possibly be a cluster of double reads?

``` {r confirm corticotrophs extra, echo=FALSE, fig.height=3.5, message=FALSE}

#Visualise the canonical marker genes 
#then id the corticotrophs

FeaturePlot(data, features = c("Tbx19", "Tnnt1","Tnni3","Gm15543"), pt.size = 0.2) &scale_color_viridis_c() 

```

These plots would suggest cluster 6 is the most likely corticotroph cluster.

\newpage
## Step 7. Isolate desired cell cluster

To examine cell homogeneity within the corticotrophs, the cluster identified in the previous step was pulled out as a subset. 

The desired cluster must be manually entered upon visual inspection of the gene expression feature plots in the previous step.
``` {r isolate desired cells, echo=FALSE}
#enter the cotricoph cell ids, found in visualisation. Note change to correct cluster #s or will miss-match
#new.cluster.ids <- c("0", "1", "2", "3", "4", "5", "6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22")
new.cluster.ids <- c("0", "1", "2", "3", "4", "5", "cort","7","8","9","10")

names(new.cluster.ids) <- levels(data)
```
As a sanity check that the correct cluster was selected, a dimensional reduction plot;

``` {r re-plot clusters with names,fig.height=3.5, echo=FALSE, warning=FALSE}
#Rename the cluster
data <- RenameIdents(data, new.cluster.ids)
#then put on the plot to confirm selected the correct one (sanity check)
DimPlot(data, reduction ="umap", label = TRUE, pt.size = 0.5)+NoLegend()
```

And the data for the cluster of interest can be extracted for further study.
``` {r pull out cluster, include=FALSE}
cortico <- subset(data, idents = "cort")
```

\newpage
## Step 8. Re-cluster selected cell cluster

To investigate cell homogeneity within the cell cluster of interest, the same procedure may be repeated;

*Data transformation, identification of principal components (PCA)
*Dimensional reduction (UMAP)
*Identification of nearest neighbours (SNN)
*Clustering using SNN.

``` {r re-cluster selected cluster, include=FALSE}

#dimensional analysis
#PCA to identify PCs
cortico <- RunPCA(cortico,verbose= FALSE) 

```
Elbow plot to establish dimensionality

``` {r elbow 2, echo = FALSE,fig.height=3.5}
#Do we need to keep all PCs, or is majority of data captured by a certain point?
ElbowPlot(cortico, ndims=30)

```

Identify most of information retained in 6 PCs

``` {r dimension reduction on reclustyer, include = FALSE}
#dimensional reduction
#UMAP dimensional reduction of the identified PCs #change dims!
cortico <- RunUMAP(cortico, dims=1:6, verbose=FALSE) #note because SCTransform passes 3000 features can run more PCs

#Find nearest neighbours #change dims!
cortico <- FindNeighbors(cortico, dims=1:6, verbose=FALSE)

#CLuster based on neighbour distances
cortico <- FindClusters(cortico, verbose=FALSE)

```


A dimensional reduction plot can then reveal any heterogeneity in the cluster;

```{r cluster homogeneity? plot any clusters of the selected cluster, echo=FALSE,fig.height=3.5, message=FALSE}
#plot the clusters
DimPlot(cortico, pt.size = 5, label=TRUE) + NoLegend()

```

A featureplot can be used to examine gene expression levels across these clusters within the corticotroph data;

``` {r clustre Pomc expression- could be any gene! , echo=FALSE,fig.height=3.5, message=FALSE}
#Visualise the canonical marker genes 
FeaturePlot(cortico, features = c("Pomc"), pt.size = 5, label=TRUE)& scale_color_viridis_c()

```


Differential expression analysis can reveal differences between the clusters, for example the two top deferentially expressed genes for each cluster are;
```{r examin cluster differential expression, include=FALSE} 
#examine DE genes in the  corticotroph cluster
#find the markers for EVERY CLUSTER when compared to remaining cells, only +ve ones
cortico.markers <-FindAllMarkers(cortico, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
#examine top 2 deferentially expressed genes in each corticotroph cluster
df <- cortico.markers %>% group_by(cluster) %>% top_n(n=2, wt= avg_logFC)

```

``` {r differential expression summary, echo=FALSE,message=FALSE}
head(df)

```
\newpage
## 9. Summary

This analysis based on 14 of 30 possible principal components shows cluster 6 to be the corticotophs. When re-clustered, the corticotrophs demonstrate cell heterogeneity with two visible sub clusters.A differential gene expression analysis of these three sub-clusters shows the top differentiated genes in each cluster to be Meg3 & Malat1 (not statistically significant) in cluster zero and Rps18-ps3 & Mif in cluster one.  







    
